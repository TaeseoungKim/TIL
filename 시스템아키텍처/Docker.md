## 왜 도커(Docker)를 사용해야 하는가?

개발자의 PC에서 잘 작동하던 애플리케이션이 서버에 올리고 나서 에러가 발생하는 경우가 있다. PC와 서버의 구동 환경의 차이라고 할 수 있다. 운영체제의 차이일 수도 있고, 양쪽 환경의 프레임워크, 기타 종속 모듈의 버전 차이일 수도 있다.

컨테이너의 고찰

컨테이너(container)는 애플리케이션을 환경에 영향받지 않고 실행하는 기술이다. 애플리케이션뿐만 아니라 애플리케이션을 실행하는데 필요한 모든 환경을 포함한다. 따라서 도커 컨테이너는 애플리케이션 + 애플리케이션 구동에 필요한 모든 환경을 포함한다. 리눅스 환경에서 운영되는 도커 컨테이너 예를 들어보면 다음과 같이 구성된다. 컨테이너는 라이브러리, 시스템 도구, 코드, 런타임 빌드를 포함한 소프트웨어가 구동되는 표준화된 단위다.

![](https://i.imgur.com/6POPmEa.png)

## 도커와 가상머신(VM)의 차이

둘 다 이미지라는 개념이 적용되고 가상머신 또한 이미지 내에 운영체제와 라이브러리, 종속성, 애플리케이션을 모두 담을 수 있지만 구동 환경 자체가 다르다고 할 수 있다. 가상머신은 하이퍼바이저 위에 Guest OS가 각각 인스턴스 별로 필요하고 운영되는 반면, 도커는 호스트 운영체제 1개에 도커가 생성되어 애플리케이션이 각각 운영되어 좀 더 가벼운 구조라 할 수 있다.

![](https://i.imgur.com/1Fu4vuF.png)

컨테이너가 일반적인 가상 머신(VM)보다 좋은 점을 정리하면..

- 가벼운 구조의 컨테이너 클러스터를 활용한 손쉬운 스케일링
- 내구성(Fault Tolerant) - 모든 컨테이너가 down 되진 않는다.
- 쉬운 유지관리 (관련 로그를 모니터링 도구를 통해 조회)

## 왜 도커가 필요한가?

동일한 서버가 2대 있다고 가정해 보자. 각각의 서버를 A, B라고 했을 때 동일한 애플리케이션이 운용됨에도 불구하고 A보다 B 서버가 자주 죽을 수 있다. 이때 B 서버를 눈송이 서버(snowflake server)라 하며 각자의 운용 기록을 가지고 고유한 모습을 유지하기에 수동(manual) 적인 구성이 필요하다.

도커에서는 이 역할을 Dockerfile을 통해 관리하여 서버의 기록을 코드화한다. Dockerfile 예제는 아래.

```
# syntax=docker/dockerfile:1
FROM ubuntu:18.04
COPY . /app
RUN make /app
CMD python /app/app.py
```

FROM: ubuntu:18.04 도커 이미지로부터 레이어(layer) 하나를 생성한다.
COPY: Docker 클라이언트의 현재 디렉터리에서 애플리케이션 파일을 추가한다.
RUN: make 명령으로 애플리케이션을 빌드 한다.
CMD: 컨테이너에서 수행할 특정 명령(command)를 설정한다.

Dockerfile을 빌드 하며 도커 이미지를 생성하며, 도커 이미지는 실행 환경을 포함하기 때문에 A, B 서버 어디에서 구동해도 정상적인 빌드와 운영이 가능하다
