## why TypeSciprt

자바스크립트에서는 아래와 같은 괴상한 문법을 허용한다.

```javascript
[1, 2, 3, 4] + false; // '1,2,3,4false'

function divide(a, b) {
  return a / b;
}
divide("xxxxxxxX"); // NaN` `
```

## implicit Type, explicit Type

```typescript
let a: number = 1;
let b: string = "i1";
let c: boolean = true;
let d: boolean[] = [true];
```

명시적 표현은 최소한으로 사용하는 것이 좋다.
코드가 간결해지고, 가독성이 좋기 때문이다.

### tip) 잘못된 표현

```typescript
const player: object = {
  name: "nico",
};

player.name; // player는 object 타입이라고 명시를 했기 때문에, player는 name 속성을 가지지 않는다고 타입스크립트는 경고한다.
```

```typescript
type Player = { name: string; age?: number }
const player: Player = {
  name: "nico",
};

if(player.age < 10){ ... } // age가 undefined일 수도 있다고 타입스크립트가 경고를 띄워준다.
if(player.age && player.age < 10){ ... } // age가 존재하는지 확인하는 과정을 거치면 타입스크립트는 해당코드를 허용한다.

function playMaker(name:string) : Player {
    return {
        name
    }
}

const playMaker = (name:string): Player => {name}console.log();
```

## readonly

```typescript
type Player = { name: string; age?: number };
const player: Player = {
  name: "nico",
};

player.name = "slom"; // readlonly 속성으로 인해, 수정을 막아줄 수 있다.

const names: readonly string[]: ["1", "2"]
names.push("3") // 경고 발생, readonly이기 떄문이다.
```

## tuple

```javascript
const player: [string, number, boolean] = []; // 3개의 요소가 필요하다는 경고문구가 발생한다.
const player: [string, number, boolean] = ["nico", 1, true]; // 이처럼 타입스크립트의 "튜플"을 이용하여 특정 타입의 요소를 가진 배열(튜플)을 만들 수 있다.
```

## any

any는 타입스크립트의 default 타입이자, 타입스크립트로부터 해방하기 위한 키워드다.
사용하는 것을 지양해야한다.

## unknown

unknown 타입은 해당 변수가 어떤 타입인지 모를 때, 사용하는 타입이다. (ex. API로부터 응답받은 데이터가 어떤 형식일지 모를 때)
unknown 타입을 사용하게 되면 타입스크립트로부터 도움을 받을 수 있다.
예를 들어, 아래와 같은 코드는 경고를 뿜는다.

```typescript
let a: unknown;
let b = a + 1; // a가 어떠한 타입인지 모르기 때문에 warnning
```

아래와 같이 타입의 범위를 지정해준다면 타입스크립트는 이를 허용한다.

```typescript
let a: unknown;
if (typeof a === "number") {
  let b = a + 1;
}

if (typeof a === "string") {
  // 해당 타입 확인이 없다면 타입스크립트는 a.toUpperCase()를  허용하지 않는다.
  a.toUpperCase();
}
```

## void

아무것도 return하지 않는 함수에 사용한다.

```typescript
function hello():void{ // 하지만 타입스크립트가 자동으로 체크해주기 때문에 명시적으로 지정해주지 않아도 된다.
  ...
}

const a = hello();
a.toUpperCase(); // 경고, void 타입은 toUpperCase()를 지원하지 않기 때문

```

## never

함수가 절대 return 하지 않고, 오류를 뿜을 때 사용한다.

````typescript
function hello():void{ // 하지만 타입스크립트가 자동으로 체크해주기 때문에 명시적으로 지정해주지 않아도 된다.
throw new Error("xxx");
}```
````

또는, 아래와 같이 발생할 수 없는 형식의 타입을 뜻한다

```typescript
function hello(name:string|number){ // 하지만 타입스크립트가 자동으로 체크해주기 때문에 명시적으로 지정해주지 않아도 된다.
if (typeof name === "string"){
 ... // 해당 블락안에서는 string로 취급한다
}else if (typeof name === "number"){
  ... // 해당 블락안에서는 number로 취급한다
}else {
// 해당 블락안에서는 never~!!
}
```

## call signatures

call signatures는 타입스크립트에서 코드에 마우스를 hover했을 때, 보이는 코드에 대한 정보이다.
매번 아래와 같이 적는 것은 보기에도 안좋다.

```typescript
function hello(name: string | number): number { ... }
```

위와 같이 하는 것이 아닌, 함수의 type을 지정해보자.

```typescript
type Add = (a: number, b: number) => number;
const add: Add = (a, b) => a + b;
```

## Overloading(다형성)

타입스크립트의 Overloading은 타입의 여러 모습을 가질 수 있도록 하는 것이다.

```typescript
type Add = { // 이렇게 오버로딩을 할 수 있다
  (a: number, b: number) => number
  (a: number, b: string) => number

};
const add: Add = (a, b) => a + b; // 타입스크립트는 경고를 발생시킨다. a는 number가 확실하지만, b는 number인지 string인지 알 수 없기 떄문에 number + string을 막는 것
```

이렇듯, 타입스크립트에서의 오버로딩은 call signature가 여러개 있는 것이라 생각하면 된다.

```typescript
type Add = { // 이렇게 오버로딩을 할 수 있다
  (a: number, b: number) => number
  (a: number, b: string) => number

};
const add: Add = (a, b) => a + b; // 타입스크립트는 경고를 발생시킨다. a는 number가 확실하지만, b는 number인지 string인지 알 수 없기 떄문에 number + string을 막는 것
```

nextJS의 router.push가 잘만든 오버로딩의 예이다.
간단히 구현해보자.

```typescript
type Config = {
  path: string;
  state: object;
};

type push = {
  (path: string): void;
  (config: Config): void;
};

const push: Push = (config) => {
  if (typeof config === "string") console.log(config);
  else {
    console.log(config.path, config.state);
  }
};
```

파라미터가 개수가 다르다면 어떨까?

```typescript
type Add = {
  (a: number, b: number): number;
  (a: number, b: number, c: number): number; // 타입스크립트는 c가 옵셔널이라고 체크한다
};

const add: Add = (a, b, c?: number) => {
  // ?:number를 지정해주지 않으면 타입스크립트는 경고를 뿜는다. 위에서 c는 옵셔널이라고 지정했기 떄문,
  if (c) return a + b + c;
  return a + b;
};
```

## generic
